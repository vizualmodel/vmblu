{"version":3,"sources":["../src/resolve-queue.js","../src/target.js","../src/runtime.js","../src/runtime-node.js","../src/runtime-filter.js","../src/scaffold.js","../src/index.js"],"sourcesContent":["// Deferred wrapper around a Promise\r\nfunction Deferred() {\r\n\r\n    // create a promise and set _resolve and _reject\r\n    this.promise = new Promise((resolve, reject) => {\r\n        this._resolve = resolve;\r\n        this._reject = reject;\r\n    });\r\n}\r\nDeferred.prototype = {\r\n  \r\n    // when deferred is resolved/rejected call the actual resolve\r\n    resolve(value) {\r\n        this._resolve(value);\r\n    },\r\n  \r\n    reject(error) {\r\n        this._reject(error);\r\n    }\r\n}\r\n\r\n// Handler that wraps one or more Deferreds in a thenable ifPins\r\nexport function PromiseHandler(defs) {\r\n    \r\n    // Only store the Deferred instances\r\n    this.defs = defs;\r\n}\r\nPromiseHandler.prototype = {\r\n  \r\n    then(onFulfilled, onRejected) {\r\n        const newDefs = this.defs.map(d => {\r\n            const next = new Deferred();\r\n            d.promise\r\n            .then(onFulfilled, onRejected)\r\n            .then(next.resolve.bind(next), next.reject.bind(next));\r\n            return next;\r\n        });\r\n        return new PromiseHandler(newDefs);\r\n    },\r\n  \r\n    catch(onRejected) {\r\n        const newDefs = this.defs.map(d => {\r\n            const next = new Deferred();\r\n            d.promise\r\n            .catch(onRejected)\r\n            .then(next.resolve.bind(next), next.reject.bind(next));\r\n            return next;\r\n        });\r\n        return new PromiseHandler(newDefs);\r\n    },\r\n  \r\n    // Dynamically resize the handler to hold `count` deferreds\r\n    replace(count) {\r\n        if (count > this.defs.length) {\r\n            for (let i = this.defs.length; i < count; i++) {\r\n                this.defs.push(new Deferred());\r\n            }\r\n        } else if (count < this.defs.length) {\r\n            this.defs.splice(count).forEach(d => {\r\n                // allow dropped promises to be GC'd by not resolving/rejecting\r\n            });\r\n        }\r\n    }\r\n}\r\n  \r\n// Queue that manages PromiseHandlers for message replies\r\nexport function ResolveQueue() {\r\n\r\n    // The min timeout is set to 1 sec\r\n    this.minTimeout = 1000;\r\n\r\n    // The queue is a map - txRef is teh key\r\n    this.queue = new Map();  // txRef -> { handler: PromiseHandler, time: {start, duration} }\r\n}\r\nResolveQueue.prototype = {\r\n  \r\n    /**\r\n     * Always returns a PromiseHandler (even for a single reply)\r\n     * @param {string} txRef - transaction reference\r\n     * @param {number} timeout - desired timeout in ms\r\n     * @param {number} count - number of expected replies (default 1)\r\n     */\r\n    addPromiseHandler(txRef, timeout, count = 1) {\r\n\r\n        // Check if need to apply the min duration\r\n        const duration = Math.max(timeout, this.minTimeout);\r\n\r\n        // Add a deffered \r\n        const defs = Array.from({ length: count }, () => new Deferred());\r\n        const handler = new PromiseHandler(defs);\r\n\r\n        this.queue.set(txRef, { handler, time: { start: Date.now(), duration } });\r\n        return handler;\r\n    },\r\n  \r\n    /**\r\n     * Replace the existing handler's deferred count\r\n     * @param {string} txRef\r\n     * @param {number} count\r\n     */\r\n    changePromiseHandler(txRef, count) {\r\n\r\n        const entry = this.queue.get(txRef);\r\n        if (!entry) return;\r\n        entry.handler.replace(count);\r\n    },\r\n  \r\n    /**\r\n     * Trigger the next deferred in line when a reply arrives\r\n     * @param {string} rxRef\r\n     * @param {*} value\r\n     */\r\n    trigger(rxRef, value) {\r\n\r\n        const entry = this.queue.get(rxRef);\r\n        if (!entry) return console.log(rxRef, 'NOT FOUND');\r\n        const d = entry.handler.defs.shift();\r\n        d.resolve(value);\r\n        if (entry.handler.defs.length === 0) {\r\n            this.queue.delete(rxRef);\r\n        }\r\n    },\r\n  \r\n    /**\r\n     * Periodically call this to reject any timed‑out handlers\r\n     * @param {number} [now=Date.now()]\r\n     */\r\n    checkTimeouts(now = Date.now()) {\r\n\r\n        for (const [txRef, entry] of this.queue.entries()) {\r\n            const { start, duration } = entry.time;\r\n            if (start + duration <= now) {\r\n\r\n                // create an error\r\n                const err = new Error(`Reply timeout for ${txRef} after ${duration}ms`);\r\n\r\n                // reject the promise\r\n                entry.handler.defs.forEach(d => d.reject(err));\r\n\r\n                // remove the entry from the queue\r\n                this.queue.delete(txRef);\r\n            }\r\n        }\r\n    }\r\n}\r\n  ","// The first four bits of the hix are used for the type of the target\r\nexport const HIX_HANDLER =   0x00000000\r\nexport const HIX_REPLY =     0x10000000\r\nexport const HIX_ROUTER =    0x20000000\r\nexport const HIX_TYPE_MASK = 0xF0000000;  // top 4 bits\r\nexport const HIX_MASK =      0x0FFFFFFF;  // lower 28 bits\r\n\r\nexport function Target(uid, pin, channel = false) {\r\n\r\n    this.uid = uid                  // The uid of the actor\r\n    this.actor = null               // The actor\r\n    this.pin = pin                  // the name of the input pin\r\n    this.channel = channel          // true if the input has a channel\r\n    this.hix = HIX_HANDLER          // the index of the input in the rx table of the actor (where the handler is)\r\n}\r\n\r\n// arrows used for targets\r\nconst arrow = '->'\r\nconst channelArrow = '=>'\r\n\r\nexport const convert = {\r\n\r\n    // just remove the arrow at the front and trim\r\n    stringToInput(str) {\r\n\r\n        const pure = str.trim()\r\n\r\n        const symbol = pure.slice(0,2)\r\n\r\n        const pin = pure.slice(2).trim();\r\n\r\n        return {\r\n            pin,\r\n            channel: (symbol === arrow) ? false : true\r\n        }\r\n    },\r\n\r\n    // make an output record for a single output string\r\n    stringToOutput(str) {\r\n\r\n        // helper function\r\n        function singleTarget(str) {\r\n            return str[0] == '[' && str.at(-1) == ']' ? false : true\r\n        }\r\n\r\n        // check if channel or not\r\n        let channel = false\r\n\r\n        let symbolIndex = str.indexOf(arrow)\r\n        if (symbolIndex < 0) {\r\n            symbolIndex = str.indexOf(channelArrow)\r\n            channel = true\r\n        }\r\n        if (symbolIndex < 0) return null\r\n\r\n        const output = str.slice(0,symbolIndex).trim()\r\n        const targetString = str.slice(symbolIndex+2).trim()\r\n\r\n        // check\r\n        if (output.length == 0 || targetString.length == 0) return null\r\n\r\n        // check if one or many\r\n        if (singleTarget(targetString))   {\r\n\r\n            const rawTarget = convert.stringToTarget(targetString)\r\n\r\n            return rawTarget ? {output, channel, targets: [rawTarget]} : {output, channel, targets: []} \r\n        }\r\n        else {\r\n\r\n            // get all the targets between \" \"\r\n            const regex = /\"(?:\\\\.|[^\"\\\\])*\"/g;\r\n            let matches = targetString.match(regex);\r\n            \r\n            // split in target strings\r\n            const targetStringArray = matches ? matches.map(str => str.slice(1, -1).replace(/\\\\\"/g, '\"')) : []\r\n\r\n            // The array to collect the targets\r\n            const rawTargets = []\r\n\r\n            // do all the target strings\r\n            for (const  target of targetStringArray) {\r\n                const rawTarget = convert.stringToTarget(target)\r\n                if (rawTarget) rawTargets.push(rawTarget)\r\n            }\r\n\r\n            // done \r\n            return {output, channel, targets: rawTargets}\r\n        }\r\n    },\r\n\r\n    // This function is used for the routertable\r\n    stringToScope(str) {\r\n\r\n        // selector and scope are seperated by a colon\r\n        let colon = str.indexOf(':')\r\n        if (colon < 0) return null\r\n\r\n        const selector = str.slice(0,colon).trim()\r\n        const scope = str.slice(colon+1).trim()\r\n\r\n        // check\r\n        if (selector.length == 0 || scope.length == 0) return null\r\n\r\n        // get all the targets between \" \"\r\n        const regex = /\"(?:\\\\.|[^\"\\\\])*\"/g;\r\n        let matches = scope.match(regex);\r\n        \r\n        // split in target strings\r\n        const targetStringArray = matches ? matches.map(str => str.slice(1, -1).replace(/\\\\\"/g, '\"')) : []\r\n\r\n        // The array to collect the targets\r\n        const rawTargets = []\r\n\r\n        // do all the target strings\r\n        for (const  target of targetStringArray) {\r\n            const rawTarget = convert.stringToTarget(target)\r\n            if (rawTarget) rawTargets.push(rawTarget)\r\n        }\r\n\r\n        // done \r\n        return {selector, scope: rawTargets}\r\n    },\r\n\r\n    // format: pin name @ node name (uid)\r\n    stringToTarget(str) {\r\n\r\n        // get the uid at the end\r\n        const uidStart = str.lastIndexOf('(')\r\n        if (uidStart < 0) return null\r\n\r\n        const uidEnd = str.lastIndexOf(')')\r\n        if (uidEnd < 0) return null\r\n\r\n        // check if there is anything\r\n        if (uidEnd - uidStart < 2) return null\r\n\r\n        const uid = str.slice(uidStart+1, uidEnd)\r\n\r\n        const atIndex = str.indexOf('@')\r\n\r\n        if (atIndex < 0) return null\r\n\r\n        const pinName = str.slice(0,atIndex).trim()\r\n        const nodeName = str.slice(atIndex+1,uidStart).trim()\r\n\r\n        if (pinName.length == 0 || nodeName.length == 0) return null\r\n\r\n        return {pinName, nodeName, uid}\r\n    },\r\n\r\n    // transforms a name to a valid javascript identifier\r\n    pinToHandler(pinName) {\r\n\r\n        const words = pinName\r\n            // and split on space, dot, or hyphen\r\n            .split(/[ .-]+/)\r\n            // Remove illegal characters from each segment, but keep underscores\r\n            .map(w => w.replace(/[^a-zA-Z0-9_]/g, ''));\r\n\r\n        // Remove empty segments (e.g. from \"foo..bar\")\r\n        const cleaned = words.filter(Boolean);\r\n\r\n        // CamelCase construction\r\n        return 'on' + cleaned.map(word  => word[0].toUpperCase() + word.slice(1)).join('');\r\n    },\r\n}","import {ResolveQueue} from './resolve-queue.js'\r\nimport {HIX_HANDLER, HIX_ROUTER, HIX_REPLY, HIX_TYPE_MASK, HIX_MASK} from './target'\r\n\r\n// The flags for the runtime \r\nexport const rtFlags = {\r\n    LOGMSG: 0x1\r\n}\r\n// shorten the flags\r\nconst LOGMSG = rtFlags.LOGMSG\r\n\r\n// the runtime defintion\r\nexport function Runtime() {\r\n\r\n    //the actors in this runtime (nodes and filters)\r\n    this.actors = []\r\n\r\n    // scheduling\r\n    this.timer = 0                          // the timer returned by setTimeout\r\n    this.minDelay = 0                       // delay when running fast\r\n    this.maxDelay = 100                     // delay when running slow\r\n    this.scheduleDelay = this.minDelay      // delay between receive scheduling\r\n    this.idleCount = 0                      // the nr of idle loops - reset to 0 when a message arrives\r\n    this.idleTreshold = 100                 // switch to slow regime after x consecutive idle loops\r\n    this.slow = false                       // regime\r\n\r\n    // msg count and time run\r\n    this.msgCount = 0                       // total messages handles\r\n    this.startTime = null                   // starting time of the runtime\r\n\r\n    // the message queues act like swinging buffers\r\n    this.qOut = []\r\n    this.qIn = []\r\n\r\n    // The queue with promises waiting to be resolved / rejected\r\n    this.qResolve = new ResolveQueue()\r\n}\r\nRuntime.prototype = {\r\n\r\n    // start the runtime\r\n    start() {\r\n\r\n        // stop the timer - if there is one running...\r\n        clearTimeout(this.timer)\r\n\r\n        // clear the send/rcv queue\r\n        this.qOut = []\r\n        this.qIn = []\r\n\r\n        // reset the counter\r\n        this.msgCount = 0\r\n\r\n        // create the cells for each actor (node or bus)\r\n        for (const actor of this.actors) actor.makeCell()\r\n\r\n        // note the time\r\n        this.startTime = Date.now()\r\n\r\n        // schedule the runtime message handler\r\n        this.timer = setTimeout(this.receive.bind(this),this.scheduleDelay)\r\n    },\r\n\r\n    // stop the timer, clear the queues and reset the cells\r\n    stop() {\r\n        // stop the receiver\r\n        clearTimeout(this.timer)\r\n\r\n        // reset the counter\r\n        this.msgCount = 0\r\n\r\n        // clear all cells (necessary ?) - maybe something else needs to be done ?\r\n        this.actors.forEach( actor => actor.cell = null)\r\n\r\n        // clear the send/rcv queue\r\n        this.qOut = []\r\n        this.qIn = []\r\n    },\r\n\r\n    halt() {\r\n        // stop the receiver\r\n        clearTimeout(this.timer)\r\n    },\r\n\r\n    continue() {\r\n        // restart the receiving process...\r\n        this.timer = setTimeout(this.receive.bind(this),this.scheduleDelay)\r\n    },\r\n\r\n    switch() {\r\n        // switch the queues\r\n        const temp = this.qIn\r\n        this.qIn = this.qOut\r\n        this.qOut = temp\r\n\r\n        // and set the new send queue to 0\r\n        this.qOut.length = 0\r\n\r\n        // switch back to fast if going slow\r\n        if (this.slow) this.goFast()\r\n    },\r\n\r\n    idle() {\r\n        // increment the idleCount\r\n        this.idleCount++\r\n\r\n        // get the time\r\n        const now = Date.now()\r\n\r\n        // check the resolve queue for timeouts\r\n        this.qResolve.checkTimeouts(now)\r\n\r\n        // **** dbg only\r\n        if (this.idleCount % 600 == 0) {\r\n            const min = (now - this.startTime)/60000\r\n            console.log(`<idle> ${this.idleCount} cycles - nr of messages: ${this.msgCount} - running time:${min.toFixed(0)} min`)\r\n        }\r\n        \r\n        // check if we need to throttle\r\n        if (( ! this.slow)&&(this.idleCount > this.idleTreshold)) this.goSlow()\r\n    },\r\n\r\n    goFast() {\r\n        this.scheduleDelay = this.minDelay\r\n        this.idleCount = 0\r\n        this.slow = false\r\n    },\r\n\r\n    goSlow() {\r\n        this.scheduleDelay = this.maxDelay\r\n        this.slow = true\r\n    },\r\n\r\n    // returns a promise that is immediately rejected\r\n    reject(reason) {\r\n        return new Promise((resolve, reject) => {\r\n            reject(new Error(reason));\r\n        });\r\n    },\r\n\r\n    // send the message to all the targets = schedule the execution of the handler\r\n    sendTo(targets, source, pin, param) {\r\n\r\n        // check\r\n        if (targets.length < 1) return 0\r\n\r\n        // dbg\r\n        //if (source.flags & LOGMSG) console.log(`send \"${pin} @ ${source.name}\"`)\r\n        if (source.flags & LOGMSG) console.log(`${source.name} -> ${pin}`)\r\n            \r\n        // keep the count\r\n        ++this.msgCount\r\n\r\n        for (const target of targets)\r\n            this.qOut.push({ from: source.uid,  txRef: 0, \r\n                             dest: target.actor, rxRef: 0,  \r\n                             hix: target.hix, pin, param})\r\n\r\n        // return the number of messages sent\r\n        return targets.length\r\n    },\r\n\r\n    // requests data from the target(s) - returns a thenable - either a promise or a promisehandler !\r\n    requestFrom(targets, source, pin, param, timeout) {\r\n\r\n        // dbg\r\n        //if (source.flags & LOGMSG) console.log(`request \"${pin} @ ${source.name}\"`)\r\n        if (source.flags & LOGMSG) console.log(`${source.name} => ${pin}`)\r\n\r\n        // increment the message counter and use as local ref\r\n        const txRef = ++this.msgCount\r\n\r\n        // count the number actual targets that have a channel\r\n        let channelCount=0\r\n\r\n        // Push the messages on the outgoing message queue. Also send txref ! It will allow to resolve the promise\r\n        for (const target of targets) {\r\n\r\n            this.qOut.push({    from:source.uid, txRef, \r\n                                dest:target.actor, rxRef:0, \r\n                                hix:target.hix, pin, param})\r\n\r\n            if (target.channel) channelCount++;\r\n            // same as : if (target.actor.rxTable[target.hix].channel) channelCount++\r\n        }\r\n\r\n        // check - if no destination with a channel, return a promise, but reject it immediately\r\n        if (channelCount == 0) return this.reject('No channel')\r\n            \r\n        // add a promise handler for the number of promises required\r\n        return this.qResolve.addPromiseHandler(txRef, timeout, channelCount)\r\n    },\r\n\r\n    // hix: -1 indicates that it is a reply - rxRef allows the receiver to find the promise\r\n    reply(source, param) {\r\n\r\n        // there must have been a request\r\n        if (! source.msg?.txRef) return 0\r\n\r\n        // dbg\r\n        if (source.flags & LOGMSG) console.log(`reply to ${source.msg.pin} @ ${source.name}`)\r\n\r\n        // keep the count\r\n        ++this.msgCount\r\n\r\n        // hix = -1 indicates that this is a reply - no txRef needed, because reply is final...\r\n        this.qOut.push({    from: source.uid, txRef:0, \r\n                            dest: source.msg.from, rxRef: source.msg.txRef, \r\n                            hix: HIX_REPLY, pin: source.msg.pin, param})\r\n\r\n        // return the number of messages sent\r\n        return 1\r\n    },\r\n\r\n    next(source, param, timeout) {\r\n\r\n       // there must have been a request\r\n       if (! source.msg?.txRef) return this.reject('No target')\r\n       \r\n        // increment the message counter and use as local ref\r\n        const txRef = ++this.msgCount\r\n\r\n        // Push the messages on the outgoing message queue. Also store txref ! It will allow to resolve the promise\r\n        this.qOut.push({    from:source.uid, txRef, \r\n                            dest:target.actor, rxRef: source.msg.txRef, \r\n                            hix: HIX_REPLY, pin: source.msg.pin, param})\r\n\r\n        // add a promise to the resolve queue\r\n        return this.qResolve.addPromiseHandler(txRef, timeout)\r\n    },\r\n\r\n    receive() {\r\n\r\n        // if nothing to do \r\n        if (!this.qOut.length) {\r\n\r\n            // do some idle bookkeeping - also check for promises that have timed out\r\n            this.idle()\r\n        }\r\n        else {\r\n\r\n            // There are messages to handle ...switch input/output queue\r\n            this.switch()\r\n\r\n            // and handle the received messages\r\n            this.handleReceiveQueue()\r\n        }\r\n\r\n        // and re-schedule the message handler\r\n        this.timer = setTimeout( this.receive.bind(this),this.scheduleDelay)\r\n    },\r\n\r\n    // handle the messages on the receive queue\r\n    handleReceiveQueue() {\r\n\r\n        // handle the messages in the in queue\r\n        for (const msg of this.qIn) {\r\n\r\n            // notation \r\n            const dest = msg.dest\r\n\r\n            switch(msg.hix & HIX_TYPE_MASK) {\r\n\r\n                // Normal messages have a positive handler index\r\n                case HIX_HANDLER : {\r\n\r\n                    // and set the current message in the destination\r\n                    dest.msg = msg\r\n\r\n                    // dbg\r\n                    //if (dest.flags & LOGMSG) console.log(`received \"${msg.pin} @ ${dest.name}\" run \"${dest.rxTable[msg.hix].handler.name}\"`)\r\n                    if (dest.flags & LOGMSG) console.log(`${dest.name} <- ${msg.pin} (run ${dest.rxTable[msg.hix].handler.name})`)\r\n\r\n                    // call the handler and set the cell as this\r\n                    dest.rxTable[msg.hix].handler.call(dest.cell, msg.param)\r\n                }\r\n                break\r\n\r\n                // replies \r\n                case HIX_REPLY : {\r\n\r\n                    // dbg\r\n                    if (dest.flags & LOGMSG) console.log(`${dest.name} <= ${msg.pin} (reply)`)\r\n\r\n                    // find the promise on the resolve queue and trigger it...\r\n                    this.qResolve.trigger(msg.rxRef, msg.param)\r\n                }\r\n                break\r\n\r\n                // messages that have to pass through a router filter first also have a special hix\r\n                case HIX_ROUTER : {\r\n\r\n                    // dbg\r\n                    if (dest.flags & LOGMSG) console.log(`${dest.name} <- ${msg.pin} (filter via router)`)\r\n\r\n                    // get the scope of the message\r\n                    const scope = msg.dest.scopeTable[msg.hix & HIX_MASK]\r\n\r\n                    // select the scope\r\n                    const nameList = dest.cell.filter?.(scope.targets.keys(), msg.pin,  msg.param) ?? [...scope.targets.keys()]\r\n\r\n                    // if there are many targets\r\n                    if (Array.isArray(nameList) && nameList.length > 0) {\r\n\r\n                        // ..call forwardAll\r\n                        this.forwardToAll(msg, nameList, scope.targets)\r\n                    }\r\n                    else {\r\n                        // there is only one target, call forward\r\n                        const actual = scope.targets.get(nameList)\r\n\r\n                        if (actual) this.forward(msg, actual)\r\n                    }   \r\n                }\r\n                break\r\n            }\r\n        }\r\n    },\r\n\r\n    // forward a message to the actual targets of the message\r\n    forwardToAll(msg, nameList, targets) {\r\n\r\n        // keep track of the number of requests\r\n        let channelCount = 0\r\n\r\n        // call the handler for each actual target\r\n        for (const name of nameList) {\r\n\r\n            // get the actual target\r\n            const actual = targets.get(name)\r\n\r\n            // check\r\n            if (actual) {\r\n\r\n                // forward\r\n                this.forward(msg, actual)\r\n\r\n                // if the message was a request, increase the channel count\r\n                if ((msg.txRef > 0) && actual.channel) channelCount++\r\n            }\r\n        }\r\n\r\n        // change to the actual number of replies expected\r\n        if (channelCount > 1) this.qResolve.changePromiseHandler(msg.txRef, channelCount) \r\n    },\r\n\r\n    forward(msg, actual) {\r\n\r\n        // for nodes call the handler for the pin\r\n        if ((actual.hix & HIX_TYPE_MASK) == HIX_HANDLER) {\r\n            \r\n            // set the current message\r\n            actual.actor.msg = msg\r\n\r\n            // call the handler\r\n            actual.actor.rxTable[actual.hix].handler.call(actual.actor.cell, msg.param)\r\n        }\r\n        // for routers, put the message on the outgoing queue\r\n        else if ((actual.hix & HIX_TYPE_MASK) == HIX_ROUTER) {\r\n\r\n            // put these on the outgoing queue\r\n            this.qOut.push({    \r\n                from:msg.from, txRef: msg.txRef, \r\n                dest:actual.actor, rxRef:0, \r\n                hix:actual.hix, pin: actual.pin, param: msg.param})\r\n        }\r\n    },\r\n\r\n    reschedule(msg) {\r\n        this.qOut.push(msg)\r\n    }\r\n}","import {runtime} from './scaffold.js'\r\nimport {rtFlags} from './runtime.js'\r\nimport {Target, convert, HIX_HANDLER, HIX_ROUTER} from './target.js'\r\n\r\nfunction RX(pin, channel=false) {\r\n\r\n    this.pin = pin\r\n    this.channel = channel\r\n    this.handler = null\r\n}\r\n\r\nfunction TX(pin, channel=false) {\r\n\r\n    this.pin = pin\r\n    this.channel = channel\r\n    this.targets = []\r\n}\r\n\r\n\r\n// the this is the cell for this function\r\nfunction missingHandler(param) {\r\n\r\n    const names = Object.getOwnPropertyNames(this)\r\n\r\n    console.warn(`Missing handler for cell: ${names} - parameters: ${param}`)\r\n}\r\n\r\nfunction shouldUseNew(factory) {\r\n\r\n    // trivial check\r\n    if (typeof factory !== 'function' || !factory.prototype) return false;\r\n\r\n    // get the keys of the object\r\n    const protoKeys = Object.getOwnPropertyNames(factory.prototype);\r\n\r\n    // If prototype has only 'constructor' pointing back to function → treat as factory, else call with 'new'\r\n    return (protoKeys.length !== 1 || protoKeys[0] !== 'constructor' || factory.prototype.constructor !== factory)\r\n}\r\n\r\n// make this into a class and hide the props using #\r\nexport function RuntimeNode({name, uid, factory, inputs, outputs, sx, dx}) {\r\n\r\n    // name and uid of the node\r\n    this.name = name\r\n    this.uid = uid\r\n\r\n    // the node factory\r\n    this.factory = factory\r\n\r\n    // the factory can be called with new if it is a function and if the constructor does **not** point back to the function itself\r\n    this.useNew = shouldUseNew(factory) //factory.prototype?.constructor === factory ? false : true\r\n\r\n    // the receive and transmit table\r\n    this.rxTable = []\r\n    this.txTable = []\r\n\r\n    // the parameters for the node\r\n    this.sx = sx ?? null;\r\n\r\n    // the runtime settings\r\n    this.dx = dx ?? null;\r\n\r\n    // set the flags\r\n    this.flags = 0x0; \r\n\r\n    // the client data structure with the handlers - created by the factory \r\n    this.cell = null\r\n\r\n    // set when a message is received\r\n    this.msg = null\r\n\r\n    // now set the flags for the node\r\n    this.setFlags()\r\n\r\n    // initialise the rx and tx tables\r\n    this.initRxTxTables( {inputs, outputs})\r\n}\r\nRuntimeNode.prototype = {\r\n\r\n    setFlags() {\r\n\r\n        if (! this.dx?.flags) return\r\n\r\n        if (this.dx.flags.includes('LOGMSG')) this.flags |= rtFlags.LOGMSG\r\n    },\r\n\r\n    initRxTxTables({inputs,outputs} ) {\r\n\r\n        // handle the inputs\r\n        for ( const inputString of inputs) {\r\n\r\n            // convert the string to an input\r\n            const input = convert.stringToInput(inputString)\r\n            if (input) this.rxTable.push(new RX(input.pin, input.channel));\r\n        }\r\n\r\n        // handle the outputs\r\n        for (const outputString of outputs) {\r\n\r\n            // first get the output \r\n            const raw = convert.stringToOutput(outputString);\r\n\r\n            // check\r\n            if (!raw) continue\r\n\r\n            // a new transmit entry\r\n            const tx = new TX(raw.output, raw.channel)\r\n\r\n            // save\r\n            this.txTable.push(tx)\r\n\r\n            // add the targets\r\n            for (const rawTarget of raw.targets) {\r\n\r\n                // add the output pin\r\n                tx.targets.push(new Target(rawTarget.uid, rawTarget.pinName, raw.channel))\r\n            }\r\n        }\r\n    },\r\n\r\n    makeCell() {\r\n\r\n        // create the cell by using 'new' or a factory function\r\n        try {\r\n            if (this.useNew) {\r\n                this.cell = new this.factory(this.getTx(), this.sx);\r\n            } else {\r\n                this.cell = this.factory(this.getTx(), this.sx);\r\n            }\r\n        } catch (err) {\r\n            // Handle \"Class constructor ... cannot be invoked without 'new'\"\r\n            if (err instanceof TypeError && typeof this.factory === 'function' && /class constructor/i.test(err.message)) {\r\n            \r\n                // change the flag\r\n                this.useNew = true\r\n\r\n                // do it again, but with new this time !\r\n                this.cell = new this.factory(this.getTx(), this.sx);\r\n            }\r\n            else throw err;\r\n        }\r\n\r\n        // set the handlers in the rx Table\r\n        this.addHandlersForCell()\r\n    },\r\n\r\n    addHandlersForCell() {\r\n\r\n        // if there is no cell \r\n        if (!this.cell) {\r\n            if (this.rxTable?.length > 0) console.warn(`** NO HANDLERS ** Node ${this.name} has input pins but no implementation.`);\r\n            return;\r\n        }\r\n\r\n        // get the props of the cell\r\n        const entries = Object.entries(this.cell);\r\n\r\n        // notation\r\n        const proto = Object.getPrototypeOf(this.cell) \r\n\r\n        // get the prop names of the prototype\r\n        const protoNames = Object.getOwnPropertyNames( proto) ?? []\r\n\r\n        // check the prototype names\r\n        for (const protoName of protoNames) {\r\n\r\n            // save to entries \r\n            if (typeof proto[protoName] === 'function') entries.push([protoName, proto[protoName]])\r\n        }\r\n\r\n        // check the entries for handlers\r\n        entries.forEach(([name, fn]) => {\r\n\r\n            // only check the functions\r\n            if (typeof fn === 'function') {\r\n\r\n                // check if the function name matches a message..\r\n                const rx = this.getRx(name);\r\n\r\n                // if so set the function as the handler for the message\r\n                if (rx) rx.handler = fn;\r\n            }\r\n        });\r\n\r\n        // check that every message has a handler\r\n        this.rxTable.forEach(rx => {\r\n\r\n            // if no handler\r\n            if (!rx.handler) {\r\n\r\n                // issue a warning\r\n                console.warn(`** NO HANDLER ** Node \"${this.name}\" has input pin \"${rx.pin}\" but no handler for it.`);\r\n\r\n                // and use a default handler\r\n                rx.handler = missingHandler;\r\n            }\r\n        });\r\n    },\r\n\r\n    // given a function name, check if it corresponds to a pin in the rx table\r\n    getRx(functionName) {\r\n\r\n        // first try the old names...\r\n        if ((functionName.startsWith(\"-> \")) || (functionName.startsWith(\"=> \"))) {\r\n\r\n            // get the name without the prefix\r\n            const handlerName = functionName.slice(3)\r\n\r\n            // find the entry in the table and set the handler\r\n            return this.rxTable.find( rx => rx.pin == handlerName)\r\n        }\r\n\r\n        // try the new camelcased name\r\n        return this.rxTable.find( rx => convert.pinToHandler(rx.pin) == functionName)\r\n    },\r\n\r\n    resolveUIDs(actors) {\r\n\r\n        // for every output pin\r\n        this.txTable.forEach( tx => {\r\n\r\n            // for every pin connected to that output pin\r\n            tx.targets.forEach( target => {\r\n\r\n                // find the node\r\n                target.actor = actors.find( actor => actor.uid == target.uid)\r\n\r\n                // check - should not happen \r\n                if (!target.actor) return console.error(`** ERROR ** target node ${target.uid} in ${this.name} not found`)\r\n\r\n                // find the index of the handler for a node - note that target.channel has already been set\r\n                target.hix = target.actor.factory   ? HIX_HANDLER | target.actor.rxTable.findIndex( rx => rx.pin == target.pin) \r\n                                                    : HIX_ROUTER | target.actor.scopeTable.findIndex( scope => scope.selector == target.pin)\r\n            })\r\n        })\r\n    },\r\n\r\n    // when sending a message find the targets for the message\r\n    findTargets(pin) {\r\n\r\n        //check\r\n        if (!pin) return []\r\n\r\n        // find the pin\r\n        const tx = this.txTable.find( tx => tx.pin == pin)\r\n\r\n        // check - targets is always an array, but it can be empty\r\n        if (tx) return tx.targets\r\n\r\n        // not found - give a warning\r\n        console.warn(`** NO OUTPUT PIN ** Node \"${this.name}\" pin: \"${pin}\"`, this.txTable)  \r\n        \r\n        //..and return null\r\n        return [] \r\n    },\r\n\r\n    // return an object with the functions for the cell - done like this to avoid direct access to source !\r\n    getTx() {\r\n\r\n        const source = this\r\n\r\n        return {\r\n            // get the output pin from the message\r\n            get pin() {return source.msg?.pin},\r\n\r\n            // returns the local reference of the message\r\n            send(pin, param) {\r\n\r\n                // check\r\n                if (!pin) return 0\r\n\r\n                // get the targets for this pin\r\n                const targets = source.findTargets(pin)\r\n\r\n                // send\r\n                return runtime.sendTo(targets, source, pin, param)\r\n            },\r\n\r\n            // sends a request and returns a promise or an array of promises\r\n            request(pin, param, timeout = 0) {\r\n\r\n                // check\r\n                if (!pin) return null\r\n\r\n                // get the targets for this pin\r\n                const tx = source.txTable.find( tx => tx.pin == pin)\r\n\r\n                // check\r\n                if (tx?.targets.length) return runtime.requestFrom(tx.targets, source, pin, param, timeout)\r\n\r\n                // not found - give a warning\r\n                console.warn(`** NO OUTPUT PIN ** Node \"${this.name}\" pin: \"${pin}\"`, this.txTable)  \r\n\r\n                // and abort the request\r\n                return runtime.reject('Not connected')\r\n            },\r\n\r\n            // Returns a message to the sender over the backchannel\r\n            reply(param) {\r\n\r\n                // a reply to a request\r\n                return runtime.reply(source, param)\r\n            },\r\n\r\n            // sends a reply and returns a promise\r\n            next(param, timeout = 0) {\r\n\r\n                return runtime.next(source, param, timeout)\r\n            },\r\n\r\n            // if a message cannot be handled yet, it can be rescheduled\r\n            reschedule() {\r\n                if (source.msg) runtime.reschedule(source.msg)\r\n            },\r\n\r\n            // you can select a destination here - message will only be sent if there is a connection to that node\r\n            wireless(nodeName) {\r\n\r\n                // find the node in the runtime - use the lowercase name to find a node !\r\n                const node = runtime.actors.find( actor => actor.name.toLowerCase() == nodeName.toLowerCase())\r\n\r\n                // check\r\n                if (!node) {\r\n                    console.warn(`** WIRELESS SEND TO UNKNOWN NODE ** ${nodeName}`)\r\n                    return {\r\n                        send(pin, param) {return 0},\r\n                        request(pin, param, timeout = 1000) { return new Promise((resolve, reject) => {reject(new Error('no node'));});}   \r\n                    }\r\n                }\r\n\r\n                // A helper function - we know that node exists\r\n                function makeTarget(pin) {\r\n                    const L = node.rxTable.length\r\n                    for(let i = 0; i < L; i++) {\r\n                        if (node.rxTable[i].pin == pin) {\r\n\r\n                            // return a target\r\n                            return {\r\n                                uid: node.uid,         \r\n                                actor: node,\r\n                                pin,           \r\n                                channel: node.rxTable[i].channel,  \r\n                                hix: HIX_HANDLER || i,      \r\n                            }\r\n                        }\r\n                    }\r\n                    return null\r\n                }\r\n\r\n                return {\r\n\r\n                    // sends a message over a pin\r\n                    send(pin, param) {\r\n\r\n                        // find the receiving pin in the node\r\n                        const target = makeTarget(pin)\r\n\r\n                        // check\r\n                        if (!target) {\r\n                            console.warn(`** WIRELESS SEND TO UNKNOWN PIN ** ${nodeName} pin: ${pin}`)\r\n                            return 0\r\n                        }\r\n\r\n                        // send\r\n                        return runtime.sendTo([target], source, pin, param)\r\n                    },\r\n\r\n                    // sends a request and returns a promise or an array of promises\r\n                    request(pin, param, timeout = 0) {\r\n\r\n                        // find the receiving pin in the node\r\n                        const target = makeTarget(pin)\r\n\r\n                        if (!target) {\r\n                            console.warn(`** WIRELESS REQUEST TO UNKNOWN PIN ** ${nodeName} pin: ${pin}`)\r\n                            return new Promise((resolve, reject) => {reject(new Error('no pin'));});  \r\n                        }\r\n\r\n                        // send out the request\r\n                        return runtime.requestFrom([target], source, pin, param, timeout)\r\n                    },\r\n                }\r\n            }\r\n\r\n        }\r\n    },\r\n\r\n\r\n}\r\n","import {runtime} from './scaffold.js'\r\nimport {rtFlags} from './runtime.js'\r\nimport {Target, convert, HIX_HANDLER, HIX_ROUTER, HIX_MASK} from './target.js'\r\n\r\nfunction Scope(selector) {\r\n\r\n    // The selector for this scope\r\n    this.selector = selector\r\n\r\n    // For a filter we save the targets in a map\r\n    this.targets = new Map()\r\n}\r\n\r\nexport function RuntimeFilter({name, uid, filter, table}) {\r\n\r\n    // name an uid\r\n    this.name = name\r\n    this.uid = uid\r\n\r\n\t// the function to create a filter \r\n\tthis.filter = filter\r\n\r\n    // the factory can be called with new if it is a function and if  the constructor does **not** point back to the function itself\r\n    this.useNew = filter.prototype?.constructor === filter ? false : true\r\n\r\n    // The routing table - for each incoming message there is a scope - the list of possible targets\r\n    this.scopeTable = []\r\n\r\n\t// The instance of the filter\r\n\tthis.cell = null\r\n\r\n\t// the message that was received\r\n\tthis.msg = null\r\n\r\n\t// build the routing map for the filter\r\n    this.buildScopeTable(table)\r\n}\r\nRuntimeFilter.prototype = {\r\n\r\n    buildScopeTable(rawTable) {\r\n\r\n        for (const routeString of rawTable) {\r\n\r\n            // for every entry\r\n\t\t\tconst rawRoute = convert.stringToScope(routeString)\r\n\r\n            // and make the scope\r\n            const scope = new Scope(rawRoute.selector)\r\n\r\n            // for each raw target\r\n            for (const rawTarget of rawRoute.scope) {\r\n\r\n                // create a target object\r\n                const target = new Target(rawTarget.uid, rawTarget.pinName)\r\n\r\n                // add it to the scope\r\n                //scope.targets.push(target)\r\n                scope.targets.set(rawTarget.nodeName, target)\r\n            }\r\n\r\n            // save the scope - use the selector as the key\r\n            this.scopeTable.push(scope)\r\n        }\r\n    },\r\n\r\n    resolveUIDs(actors) {\r\n\r\n        // for each entry in the map\r\n        for (const scope of this.scopeTable) {\r\n\r\n            // for each entry in the scope table\r\n            for (const target of scope.targets.values()) {\r\n\r\n                // find the target actor\r\n                target.actor = actors.find(actor => actor.uid == target.uid) \r\n\r\n                // check - should not happen \r\n                if (!target.actor) return console.error(`** ERROR ** target node ${target.uid} in ${this.name} not found`)\r\n\r\n                // For a node find the index of the handler \r\n                if (target.actor.factory) {\r\n\r\n                    // find the index in the rx table (the table with the handlers)\r\n                    target.actor.rxTable.find( (rx, index) => {\r\n                        if (rx.pin != target.pin) return false\r\n                        target.hix = HIX_HANDLER | index\r\n                        target.channel = rx.channel\r\n                        return true\r\n                    })\r\n                }\r\n                else if (target.actor.filter) {\r\n\r\n                    // find the index in the routing table \r\n                    target.actor.scopeTable.find( (scope, index) => {\r\n                        if (scope.selector != target.pin) return false\r\n                        target.hix = HIX_ROUTER | index\r\n                        return true\r\n                    })\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    // create a cell for the node - pass a client runtime to that cell\r\n    makeCell() {\r\n\r\n        // create the cell\r\n        this.cell = this.useNew ? new this.filter() : this.filter() \r\n    },\r\n\r\n}\r\n","import {Runtime} from './runtime.js'\r\nimport {RuntimeNode} from './runtime-node.js'\r\nimport {RuntimeFilter} from './runtime-filter.js'\r\n\r\nexport let runtime = null\r\n\r\n// this function gets the name of the file to load from the initial page and starts the runtime\r\nexport function scaffold(nodeList, filterList = []) {\r\n\r\n    // create a new runtime structure\r\n    runtime = new Runtime()\r\n\r\n    // create the run time nodes\r\n    for (const rawNode of nodeList) {\r\n\r\n        // create the node\r\n        const actor = new RuntimeNode( rawNode )\r\n\r\n        // save the node in the runtime\r\n        runtime.actors.push( actor )\r\n    }\r\n\r\n    // create the routers\r\n    for(const rawFilter of filterList) {\r\n\r\n        // create the runtime router\r\n        const actor = new RuntimeFilter( rawFilter )\r\n\r\n        // save in the actors list\r\n        runtime.actors.push( actor )\r\n    }\r\n\r\n    // resolve the uids in the target\r\n    runtime.actors.forEach(actor => actor.resolveUIDs(runtime.actors))\r\n\r\n    // done \r\n    return runtime\r\n}","export {scaffold} from './scaffold.js'\r\nexport const VERSION = '0.1.1'; // handy to confirm the loaded build"],"mappings":"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","names":["str","target","target","target","tx","target","scope"]}