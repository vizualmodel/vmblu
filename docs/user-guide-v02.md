
![logo](./logo/vmblu-512.png)

# vmblu User Guide

> **vmblu ‚Äî Visual, structured, AI-native architecture.**  
> Build software as connected nodes. Your model is the app ‚Äî explicit, navigable, and built to collaborate with LLMs.

---

## TL;DR

**Problem:**  
LLMs make coding fast, but as projects grow, context shatters and architecture turns to spaghetti.

**Solution ‚Äî vmblu:**  
A graphical, JSON-backed model where nodes pass messages. The model stays the single source of truth for humans *and* LLMs.

**What you get:**  
- A **map** of your system that is executable.  
- **Parallel AI** co-dev: multiple LLMs generate node code safely against a shared contract.  
- **Instant navigation** between model ‚Üî code (pin *Profiles* jump to handlers and `tx.send` sites).  
- **MCP tools** export so LLMs can use your app as callable services.

üëâ Jump to [Quickstart](#quickstart) to build your first vmblu app in 10 minutes.

---

## Requirements & Install

### Requirements
- Node.js **18+** (20+ recommended)
- One of:
  - **VS Code extension** (recommended): open `.vmblu` files directly.
  - **Browser app**: modern Chromium-based browser.
- A project folder with write access.

### Install
```bash
npm install @vizualmodel/vmblu
````

* In VS Code, install/open the vmblu extension and create a new `.vmblu` model.
* In the browser app, open your project folder and create a `.vmblu` model.

---

## Minimal Project Skeleton

> Just enough to run a generated `app.js`.

`package.json`

```json
{
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "@vizualmodel/vmblu": "^0.1.0"
  }
}
```

`index.html`

```html
<!doctype html>
<html>
  <head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"></head>
  <body>
    <script type="module" src="./app.js"></script> <!-- generated by ‚ÄúMake app‚Äù -->
  </body>
</html>
```

After **Make app**, serve with `npm run dev` (or your setup) and open the page.

---

## First-Run Checklist

* [ ] **Factories**: `factories` in the model points to your sources (e.g., `{"key":"_","path":"./src"}`).
* [ ] **Handlers**: each input pin has a matching `onX` handler returned by the factory.
* [ ] **Sends**: use `tx.send('exact output pin name', payload)` (don‚Äôt alias the message name).
* [ ] **Console**: open DevTools; vmblu logs clear warnings for missing pins/handlers.
* [ ] **Re-generate**: changed model? click **Make app** again.

---

## Core Concepts

### Nodes

* **Source node** *(factory icon)* ‚Äî implemented in code.
* **Group node** *(group icon)* ‚Äî contains a sub-model; behaves as one node externally.
* **Linked node** *(link / padlock)* ‚Äî imported from another file or bundle.

![node types](./figures/node-types.png)

### Pins & Interfaces

* **Input** ‚Üî handler (`onX`).
* **Output** ‚Üî `tx.send('message', payload)`.
* **Request/Reply**: output/input pair with back-channel (promise semantics).
* **Interfaces**: named sections grouping pins; prefix/suffix rules (`. - _ +`) for name composition.

![pins and interfaces](./figures/pins-interfaces.png)

### Routes

* Orthogonal routing for clarity.
* Multi-message pins displayed wider.
* Any output can connect to any input (names don‚Äôt need to match).

![routes](./figures/routes.png)

### Buses

* **Busbar** ‚Äî broadcast; connects all outputs to all inputs.
* **Cable** ‚Äî connects inputs to outputs **with the same name**; ideal for interface symmetry.
* **Router (on a cable)** ‚Äî filter selects actual recipients among the pre-matched pins.

![buses](./figures/buses.png)

### Pads (group IO)

Pads expose group node IO internally; you can ‚Äúextrude‚Äù a pin into a pad for clarity.

![pads](./figures/pads.png)

---

## Working with LLMs

> **Work with LLMs the way they work best.**

### Why vmblu + LLMs works

* **Explicit contract** ‚Äî the model JSON is LLM-readable.
* **Parallelization** ‚Äî different nodes can be built by different LLMs simultaneously.
* **Tight feedback** ‚Äî pin *Profiles* link to handlers and `tx.send` call sites.
* **MCP exposure** ‚Äî vmblu can generate an MCP tools file from handlers tagged `@mcp`.

### Collaboration loop

1. You sketch the architecture (nodes, pins, routes, buses).
2. LLM proposes/refines code inside that contract.
3. vmblu updates **profiles** and **MCP tools**; you run & test.
4. Iterate: split nodes, promote to a group node, or link nodes across files.

### Prompt patterns

* **Generate handlers**

  > ‚ÄúImplement handlers for Node X. Respect naming (onX), add `@node` + `@prompt` tags.‚Äù
* **Refactor nodes**

  > ‚ÄúSplit Node Y into Y1/Y2; keep public pins identical; add one private route.‚Äù
* **Expose to MCP**

  > ‚ÄúInclude only handlers tagged `@mcp` in the tools file.‚Äù

### LLM guardrails (copy into your prompts)

* Do **not** rename pins or interfaces.
* Do **not** change `tx.send` pin names.
* Keep the factory signature `(tx, sx)` and return handlers named `onX`.
* Use `@node`, `@prompt`, and `@mcp` JSDoc tags where relevant.
* Avoid wrapping/aliasing `tx.send`/`tx.request` calls; keep message names as string literals.

---

## Using the Editor

### Canvas

* Pan (drag background) ‚Ä¢ Zoom (scroll wheel) ‚Ä¢ 1:1 toggle ‚Ä¢ Grid toggle

### Selections

* Click node/pin to select ‚Ä¢ Shift-drag for multi-select
* Ctrl-drag a **pin** to reposition inside a node
* Ctrl-drag an **interface name** to move its block

![selection](./figures/selection.png)

### Context menus

* **Background**: new node, busbar/cable, paste / paste as link
* **Node header**: convert to group/source, make test node, cut/get/save link, ungroup
* **Pin area**: new request/reply, add/remove channel, view **Profile**
* **Bus**: convert busbar‚Üîcable, add router, straighten connections, disconnect, delete

### Key features

* **Accept changes** for linked nodes
* **Sync model** across files
* **Set save point / Back to save point**
* **Group selection** ‚Üí wrap into a group node

---

## Source Integration

### Factories & lifecycle

A node is instantiated by a factory or class: `(tx, sx) ‚Üí objectWithHandlers`.

* `tx`: transmitter (send/request/reply APIs, `pin`, `reschedule`, `wireless`)
* `sx`: node settings (from the **cog** icon)
* `dx`: runtime settings (worker/debug); **not** passed to the node

### Handler mapping

Input pin `"set canvas size"` ‚Üí handler `onSetCanvasSize`

* Case-insensitive; non-ident characters stripped; words ‚Üí PascalCase; prefixed with `on`.

### `tx` API

* `tx.send(pinName, payload) ‚Üí numberDelivered`
* `tx.request(pinName, payload, { timeout? }) ‚Üí Promise<any>`
* `tx.reply(result)`, `tx.next(partial)` (back-channel conversation until `reply`)
* `tx.reschedule()` (requeue current message)
* `tx.pin` (originating output pin name)
* `tx.wireless(nodeName).send/request(...)` (use sparingly; great for MCP/test nodes)

### JSDoc tags (used by vmblu)

* `@node <node name>` ‚Äî scopes handlers to a node in a file
* `@prompt <text>` ‚Äî LLM-friendly description for a handler
* `@mcp` ‚Äî include handler in generated MCP tools
  *(TS types are read directly; in JS, use JSDoc for types.)*

---

## Generate & Run

### Make app

Generates `app.js` with:

* Imports of factories & routers
* **Node list** (`name`, `uid`, `factory`, `inputs`, `outputs`, `sx`, `dx`)
* **Router list** (filter + table of possible destinations)

### Start runtime

```js
import * as VMBLU from '@vizualmodel/vmblu'

const runtime = VMBLU.scaffold(nodeList, routerList)
runtime.start()
```

### Console warnings

* `** NO HANDLERS **` ‚Äî node has inputs but factory returned no handlers.
* `** NO HANDLER **` ‚Äî input pin exists but handler is missing.
* `** NO OUTPUT PIN **` ‚Äî `tx.send` used with a non-existent output pin name.

---

## Patterns & Guidance

* **Split a node** when it grows too many pins or relies heavily on request/reply.
* **Promote to group node** when internals are worth modeling explicitly.
* **Busbar vs Cable vs Router**: choose clarity over route clutter.
* **Linked nodes** for reuse/multi-file organization; accept changes to stay in sync.
* **Test node** pattern: mirror IO to test a node in isolation.

---

## Troubleshooting (fast answers)

* **‚ÄúNO HANDLERS‚Äù** ‚Äî The factory returned `{}` or nothing; return an object with handlers.
* **‚ÄúNO HANDLER‚Äù** ‚Äî Input pin exists but no `onX`. Check mapping: `"set canvas size"` ‚Üí `onSetCanvasSize`.
* **‚ÄúNO OUTPUT PIN‚Äù** ‚Äî Called `tx.send('name')` but no output pin named `name` exists.
* **Profiles empty** ‚Äî Add `@node <node name>` in the source file; keep `tx.send('‚Ä¶')` **literal** (not via a var).
* **Linked node stale** ‚Äî Use **Accept changes** or **Sync model** to pull updates.

---

## FAQ

**TS or JS?** Both. TS types are read; in JS, add JSDoc for types.
**Type safety between pins?** vmblu doesn‚Äôt enforce types across nodes; enforce in code and via Profiles.
**When to use request/reply?** Sparingly. If frequent, consider merging nodes or introducing a group node.
**Busbar vs Cable?** Busbar = broadcast; Cable = same-name pins only. Add a Router to select recipients.
**Can I reuse nodes?** Yes: make a **linked node** or bundle; accept changes to stay in sync.

---

## Glossary

* **Node** ‚Äî source, group, or linked component.
* **Pin** ‚Äî input/output connection point.
* **Interface** ‚Äî group of pins with shared prefix/suffix.
* **Route** ‚Äî connection between pins.
* **Busbar** ‚Äî broadcast bus.
* **Cable** ‚Äî name-matched bus.
* **Router** ‚Äî selective filter on a cable.
* **Pad** ‚Äî group node IO exposed internally.
* **Profile** ‚Äî pin metadata linking to source code sites.
* **sx/dx** ‚Äî node vs runtime settings.
* **MCP** ‚Äî Model Context Protocol for tool integration.

---

## Appendices

### A) Keyboard Shortcuts

| Action             | Shortcut         |
| ------------------ | ---------------- |
| Create busbar      | Ctrl + B         |
| Create cable       | Ctrl + K         |
| Multi-select       | Shift + drag     |
| Move pin/interface | Ctrl + drag      |
| Undo               | Ctrl + Z         |
| Redo               | Ctrl + Shift + Z |

### B) JSDoc Cheat Sheet

```js
/**
 * @prompt Notification that a document was renamed.
 * @node document manager
 * @mcp
 * @param {Object} info
 * @param {string} info.oldName - Previous document name
 * @param {string} info.newName - New document name
 */
onDocRenamed({ oldName, newName }) { /* ... */ }
```

### C) MCP Tools Example

```js
export const mcpTools = [
  {
    name: 'camera manager_camera update',
    description: 'Trigger camera update',
    parameters: [
      { name: 'near', type: 'number' },
      { name: 'far', type: 'number' },
      { name: 'fov', type: 'number' },
      { name: 'zoom', type: 'number' },
      { name: 'aspect', type: 'number' }
    ],
    node: 'camera manager',
    pin: 'camera update',
    handler: 'onCameraUpdate'
  }
]
```

