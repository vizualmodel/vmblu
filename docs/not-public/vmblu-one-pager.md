# Vizual Model Blueprint - vmblu

## Leverage AI to build 

How to write software in the age of AI ? Can we build complex, fully featured systems that are reliabale, maintainable, understandable and safe, by leveraging the power of AI and using a fraction of the resources that it used to take ?

LLMs are the biggest shift of the programming paradigm since ever. 'Vibe coding' with LLM's can get you a long way in building an application, but often errors, inconsistencies and simply weird things will seep into the code as you iterate and the code gets more complex. These incongruities can be more or less easy to spot and correct in a small code base - or you might just not care too much for your ephemeral application - but for a larger or important application, it is crucial that the developer can understand and oversee the code.

It is no easy task to grasp the architecture of a non-trivial code base, let alone to understand it when fully generated by an LLM. We therfore need a higher-level tool that both the LLM and the human in the loop can use to reason about and design the architecture of a system.

In order to make the architecture of a system visible, we created the **vmblu graphical editor**. The vmblu editor allows to create a vmblu model, a collection of interconnected nodes. These nodes communicate by sending and receiving messages over their output and input pins. The vmblu model is not just documentation, the runable scaffold of an application is directly generated from it. The actual code for the nodes can be written using all the tools, frameworks and LLMs that a developer is happy with. The format of a vmblu model file is designed in such a way to make it easy for an LLM to understand, reason and modify it.

LLMs are not only useful to generate code, they can also be used to interface with the running system. They can use 'tools', ie run applications to get something done. When software is built as a collection of connected nodes that communicate via messages, working with an LLM to interface with such a system is natural and straightforward.

A node based system has the added advantage that nodes can be added or removed, even from a running system. This gives flexibility to reconfigure an application on the fly. This can be useful when designing or testing the application, or just to give the user this added flexibility.

**Vmblu** is a tool and therfore is and will remain open source - MIT License.

*Summary*

- Vmblu is both a graphical editor and a file format that makes the **architecture** of a system explicit and maintainable
- Vmblu builds **node based systems** - the nodes communicate via messages
- Vmblu is **AI native** software: LLMs can design, code, interface and reconfigure the model

---

## Vmblu is a graphical editor

**Vmblu** is a graphical editor and a file format for node based systems. Node-based systems have been used since long in graphical packages and are used there to define materials, meshes etc. Also no-code development environments are often based on node based architectures and libraries of standard nodes. **Vmblu** takes this a step further and uses the vmblu model as an architectural layer for the entire application, while at the same time imposing as little restrictions as possible on the nodes themselves.

With **Vmblu** you build a system as a collection of interconnected nodes. Creating the nodes, defining the inputs and outputs and connecting the nodes is all done in the **vmblu editor**. Writing the code that implements the functionality of the nodes is done using tools and packages that one normally uses: **Vmblu** is not opiniated and does not restrict the developer in his choices. **Vmblu** is available as an extension of vscode and is tightly integrated with it. You can easily navigate the code of your application from within the Vmblu model.

How many nodes you use to build your system, what the nodes do and what the inputs and outputs of the nodes are, is a matter of design and entirely up to the designer of the system. Sometimes a node will be very small and sometimes it will be huge - it all depends. In order to allow for modular design, a *group node itself* can be composed of nodes. You can also import nodes from other files, eg nodes from previous applications or from libraries of *standard nodes*

Just to give some flavour of what developing with **Vmblu** means, you can find a screenshot of a vmblu architecture below, in this case for a simulation of the solar system:

![example of a vmblu model](./figures/example.PNG)

Whenever a node produces some output it will then be delivered to the input(s) of the node(s) that it is connected to. Because systems can get big and complex, **Vmblu** allows the user to make connections in a way that keeps the model clear and easy to read. For that reason connections follow an x-y path. Also, if there are many connections, the connections can be made using a 'bus', that comes in three varities: a busbar, a cable and a router.

The vmblu model generates a runable application. Included in that application is a small runtime that switches the messages between the nodes. That runtime is also open source.

With **Vmblu** you can also generate other useful files: you can generate a scaffold for the source of a node that has been defined or create test nodes. And **Vmblu** will also make a tools file that can be used by an MCP server to allow an LLM to interface with the nodes of the application. This means that, besides using the standard UI of an application, you can also interface with the application at a deep level by simply using an LLM.

## Vmblu is AI native

In this new era of AI-assited software development, **Vmblu** helps to build sophisticated software systems 

- that are understandable and maintainable,
- that leverage the power of AI at any level, 
- at a fraction of the cost and effort that would be required otherwise,

AI is leveraged at several levels. The file format of a **Vmblu** model is designed to make it easy for an LLM to work with it: nodes, inputs, outputs and connections can easily be added. If required, the user can use the  **Vmblu** editor to clean up the graphics of the model.

Writing the code of the nodes can be done with the already available and tested tools and frameworks, assisted by AI as required.

The node based architecture also make it easy to generate a tools file for an LLM, so that it can interface with the system at the node level, while keeping complete control over what an AI is allowed to do with an application. On top of that it also makes the model itself configurable, even at run-time, by adding or removing nodes and making or breaking connections as required.


