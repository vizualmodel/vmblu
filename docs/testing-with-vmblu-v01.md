# vmblu Testing Approach

## Why Testing in the LLM Era Is Different

When code is written or co-written by LLMs, the nature of risk changes.  
LLMs make far fewer syntax errors or trivial logic mistakes than human developers.  
The bigger challenges are:

- **Trustworthiness**: LLMs can hallucinate extra behavior, misinterpret user intent, or—if a bad actor is involved—introduce malicious side-effects. We need assurance that nodes and systems do *only* what they are supposed to do.  
- **Efficiency**: LLMs may generate redundant or roundabout logic. Even if outputs are correct, wasted messages, loops, or hidden work can compromise performance and scalability.

Traditional unit tests remain useful, but they are not enough. vmblu addresses these new risks by testing at the **architectural level**: nodes, pins, and routes.

---

## Two Layers of Testing

### 1. Node-Level Mirror Testing
Each node can be paired with a **Mirror Node** that:
- Injects canonical and edge-case messages into the node.
- Validates outputs against **contracts**: what *must*, *may*, and *must never* be emitted.
- Checks **latency**, **cardinality** (1:1 vs broadcast), and **no-op cost** (efficiency under idle input).
- Enforces a **Side-Effect Manifest**: only declared capabilities (e.g., `fs.read`, `net.fetch:GET`) are allowed.

### 2. In-System Probing
Without modifying code, vmblu allows **probes** to attach to any pin, pad, or bus:
- Monitor actual message traffic for **unexpected events** or type mismatches.
- Detect **orphan routes**, unused outputs, or message storms.
- Record **golden traces** (normalized streams) for regression testing.
- Track **budgets**: per-tick message counts, route latency distributions, or allocation ceilings.
- Build causal maps of input→output flows to detect unintended data leaks.

---

## Advantages of the vmblu Approach

- **LLM-aware**: focused on the two real risks—trustworthiness and efficiency.  
- **Architectural**: tests target nodes, pins, and routes—the system’s contractual truth.  
- **Non-intrusive**: probes observe without changing node code.  
- **Deterministic**: virtual time and seeded randomness ensure reproducible runs.  
- **Traceable**: golden traces and probes provide insight into why the system behaved a certain way.  
- **Scalable**: works from single node up to full application, using the same concepts.

---

*vmblu testing ensures that code generated by LLMs is not only correct, but also **efficient, trustworthy, and free of unwanted side-effects**.*
